# /scripts – cartographie et flux utilitaires

Ce document détaille chaque script Python / shell disponible dans `scripts/`. L’objectif est de comprendre les automatisations (bootstrap, seed, imports métiers, outils de classification, tests) et les flux de données (sources → import → base) qui ton projet.

## 1. `scripts/bootstrap_local.py`
- Script d’initialisation local (schéma + fichiers restaurant + seed YAML).
- Étapes : assure la table `tenants`, applique `db/init.sql`, exécute les SQL métier `docs/restaurant/*.txt` (avec prérequis `ALTER TABLE`, vues etc.), puis lance le seed `seed_restaurant.py`. Chaque étape est désactivable via un flag `--skip-*`.
- Ce script est la base de ton environnement de dev pour synchroniser l’épicerie et Restaurant HQ.

## 2. `scripts/apply_restaurant_sql.py`
- Applique un set de fichiers SQL produits par `docs/restaurant/` pour créer vues, tables dérivées et DDL spécifiques restaurant.
- Utilise un moteur SQLAlchemy et bascule vers un curseur DBAPI lorsque `conn.exec_driver_sql` échoue (certains fichiers contiennent des instructions non standard).

## 3. `scripts/analyze_statement_names.py`
- Analyse textuelle des libellés bancaires (`restaurant_bank_statements`) : tronque chaque description à 3 tokens, agrège les alias les plus fréquents et affiche un top N.
- Ce script t’aide à identifier quels libellés devraient être regroupés dans les règles de catégorisation.

## 4. `scripts/auto_create_charges.py`
- Convertit automatiquement les relevés bancaires sans charge (`depense_id` absent) en charges restaurant via `restaurant_service.create_expense_from_bank_statement`.
- Supporte `--tenant`, `--account`, `--limit`, et `--dry-run` pour tester la transformation avant insertion.

## 5. `scripts/import_bank_pdf.py`
- Crée des mouvements bancaires à partir de PDF (format LCL) : détecte les fichiers/dossiers, extrait les octets, appelle `restaurant_service.import_bank_statements_from_pdf`, puis affiche lignes insérées/doublons.
- Résout dynamiquement `tenant_id` via `core.data_repository.get_engine()` + table `tenants`.

## 6. `scripts/import_vendor_csv.py`
- Génère ou enrichit `data/vendor_category_mapping.csv` à partir d’un CSV `vendor,category`.
- Normalise les alias (split virgules), déduit `types` (`Entrée` vs `Sortie`) et fusionne lignes existantes (avec option `--overwrite`).

## 7. `scripts/import_vendor_list.py`
- Même cible CSV, mais conçu pour des listes non structurées (domaine + lignes tabulées).
- Analyse le domaine courant, parse alias via regex, déduits `types` optionnels, et enrichit le fichier vendor category.

## 8. `scripts/normalize_catalog.py`
- Nettoie noms produits et codes-barres existants en appliquant `products_loader._normalize_name` et `_normalize_barcode`.
- Met à jour `produits` (noms standardisés), supprime les codes invalides et déduplique les doublons (`IntegrityError`).

## 9. `scripts/reclassify_bank_statements.py`
- Réexécute la catégorisation `restaurant_service._guess_category` sur les relevés existants (`--only-missing` pour cibler les vides).
- Peut tourner en `--dry-run` pour inspecter les changements avant mise à jour des catégories.

## 10. `scripts/refresh_from_pdf.py`
- Orchestrateur complet : importe tous les PDF spécifiés, génère les charges automatiques et recalcule les catégories (`_import_pdfs`, `_create_charges`, `_reclassify`).
- Flags `--skip-charges` / `--skip-reclassify` permettent de scinder le flux.

-## 11. `scripts/generate_capital_snapshot.py`
- Génère quotidiennement des lignes `capital_snapshot` en agrégeant les derniers prix (vue `latest_price_history`) et les relevés bancaires (`restaurant_bank_statements`).
- Peut être planifié via cron / scheduler pour maintenir la vue « Portefeuille » à jour.

## 12. `scripts/run-tests.sh`
- Pile de vérification locale : lance Docker Compose (`db-test`), attend `pg_isready`, configure `DATABASE_URL`, exécute `pytest`, build frontend (`npm install && npm run build`), puis stoppe et supprime les conteneurs.
- Documenté par des échos (`echo`) pour guider l’utilisateur.

## 13. `scripts/seed_restaurant.py`
- Lis le YAML `docs/restaurant/menu_seed.yaml`, upserte catégories/cost centers, insère ingrédients, plats et charges.
- Emploie `ON CONFLICT` pour éviter les doublons et garantit les relations ingredient→plat.

## 14. `scripts/start_dev_env.sh`
- Boss script shell pour mettre la stack locale : charge `.env`, ajuste `DATABASE_URL`, active `.venv`, lance `scripts/bootstrap_local`, démarre `uvicorn backend.main` (avec trap de nettoyage) et `npm run dev`.
- Idéal pour lancer toute la stack en un seul command.

## 15. `scripts/check_partie3.py`
- Requête SQL de vérification pour les plats générés via `PARTIE_3_MENU.txt`: liste les plats et leurs ingrédients pour valider le seed restaurant.

---  

Pour aller plus loin, je peux également enrichir chacun de ces scripts avec des commentaires supplémentaires ou générer un README dédié décrivant quand et comment les lancer. Souhaites-tu que je m’en occupe ? 
