# Carte mentale des modules backend

Ce document contient une cartographie détaillée des différents fichiers Python côté `backend/`. Il sert de guide rapide pour comprendre :
1. Les **routes exposées** (APIRouter) et leurs tenants fonctionnels.
2. Les **services métiers** associés et les sources de données.
3. Les **flux de données** (extraction → nettoyage → persistence → reporting).

---  

## 1. Entrée / FastAPI
- `backend/main.py` : assemble tous les routers, expose les endpoints génériques (`/health`, `/products`, `/inventory/summary`, `/pos/checkout`), et appelle `core.product_service.update_catalog_entry` pour les mises à jour d’un produit (avec validation des codes-barres). Utilise `backend.dependencies.tenant.get_current_tenant` : le tenant est résolu à partir des claims JWT (`tenant_id`, `tenant_code`), avec un fallback de sécurité `tenant_id=1`.
  * Fonctions clés :
    - `create_app()` : instancie FastAPI, ajoute le middleware CORS, inclut chaque routeur et expose les endpoints partagés (+ plan de checkout).
    - `_fetch_products()` / `_compute_inventory_value()` : interagissent avec `core.data_repository.query_df` pour alimenter la SPA (produits + synthèse valeur).
    - `checkout()` : transmet les lignes au service `core.inventory_service.process_sale_transaction` et retranscrit le reçu en Base64 pour le front.
  * Flux de données : les routes s’appuient sur les services métiers (catalogue, supply, audit...) pour composer les vues ; la mise à jour produit agit directement via `core.product_service`, garantissant cohérence entre API et services existants.

## 2. Catalogue & produits
- `backend/api/catalog.py` : pagination, filtres (recherche, catégorie, statut), actions CRUD, recherche par barcode.
- `backend/services/catalog.py` :
  * `list_products_page` construit dynamiquement `WHERE` et lit `produits et produits_barcodes`.
  * `_derive_status` produit un statut (`critical`, `warning`, `ok`) en fonction du stock et du seuil.
  * `create_product` / `update_product` maintiennent la table `produits_barcodes` via `insert_or_update_barcode`.
  * `get_product_by_barcode` normalise le code (via `core.product_service.parse_barcode_input`).
  * Fonctions et empreinte :
    - `list_products_page`, `get_product`, `create_product`, `update_product`, `delete_product`, `get_product_by_barcode`.
    - Chaque fonction lit/écrit `produits`, `produits_barcodes`, parfois `produits_barcodes`.
    - Le service utilise `core.data_repository.get_engine()` pour ouvrir des transactions et garantir l’intégrité.
  * Flux de données : API -> service `catalog` -> base `produits/barem` -> front.

## 3. Approvisionnement & plan
- `backend/api/supply.py` : paramétrage (couverture cible, seuil d’alerte, catégories, moteur de recherche) et route `/supply/plan`.
- `backend/services/supply.py` : 
  * `fetch_customer_catalog` (voir §4) fournit base (ventes 30j, stock, prix, catégories).
  * Calcul couverture (`stock / ventes_jour`), quantité à commander (`objectif - stock`), valeur, marge, niveau de priorité (Critique/Tendue/Surveillance/Confort).
  * Fusionne fournisseurs récents (`fetch_recent_suppliers`) pour générer `supplier_breakdown`.
  * Fonctions et empreinte :
    - `compute_supply_plan` manipule des DataFrames pandas/numpy à la volée pour produire `summary`, `items`, `available_categories`, `supplier_breakdown`.
    - Appelle `fetch_customer_catalog` pour la feuille de route et `fetch_recent_suppliers` pour la ventilation fournisseur.
    - Les calculs mathématiques (arrondis, `np.ceil`, `np.select`) sont orchestrés directement dans ce service, qui ne touche pas la base, hormis la lecture via `catalog_data`.
  * Flux de données : données catalogue + ventes → transformations pandas → réponse JSON structurée vers le front (plan d’appro).

## 4. Données catalogues partagées
- `backend/services/catalog_data.py` :
  * `fetch_customer_catalog` : joint `produits`, `ventes_30j`, `produits_barcodes`, renvoie GTIN nettoyé.
  * `fetch_recent_suppliers` : le dernier fournisseur par produit issu des mouvements entrants.
  * Ces fonctions alimentent supply, rapports, audit, dashboard.
  * Fonctions et empreinte :
    - `fetch_customer_catalog` retourne un DataFrame complet (`id`, `categorie`, `prix`, `tva`, `stock_actuel`, `ventes_30j`, `ean`).
    - `fetch_recent_suppliers` produit un DataFrame `produit_id`, `fournisseur`, `date_mvt`.
  * Flux de données : lecture SQL -> pandas -> retour DataFrame, consommé par les services métiers sans mutation.

## 5. Audit & écarts
- `backend/api/audit.py` : diagnostics filtrables, actions (affectation, résolution), journal des résolutions.
- `backend/services/audit.py` : 
  * SQL `stock_compare` compare stock réel vs mouvements (ENTREE/SORTIE/INVENTAIRE/TRANSFERT).
  * Tag `niveau_ecart` (Critique/Modéré/Mineur), fusion des actions existantes (`audit_actions`).
  * `create_assignment` et `update_action_status` insèrent / historisent les résolutions (`audit_resolution_log`).
  * Fonctions et empreinte :
    - `list_diagnostics`, `list_actions`, `list_resolution_log`, `create_assignment`, `update_action_status`.
    - Lecture/écriture des tables `audit_actions`, `audit_resolution_log`, `produits`, `mouvements_stock`.
    - Employe pandas pour les diagnostics, `query_df` pour les écritures.
  * Flux de données : diagnostics (SQL) → enrichissement action/responsable → API ↔ front (tableau Audit).

## 6. Stocks & mouvements
- `backend/api/stock.py` : séries temporelles `/stock/movements/timeseries`, mouvements récents `/stock/movements/recent`, ajustements `/stock/adjustments`.
- `backend/services/stock.py` :
  * `fetch_movement_timeseries` agrège par jour/type, filtrage produit+fenêtre.
  * `fetch_recent_movements` joint `mouvements_stock`/`produits`.
  * `adjust_stock_level` verrouille la ligne produit (`SELECT FOR UPDATE`), crée un mouvement correctif (ENTREE/SORTIE), puis relit le stock.
  * Fonctions et empreinte :
    - `fetch_movement_timeseries`, `fetch_recent_movements`, `adjust_stock_level`.
    - Lecture sur `mouvements_stock`, `produits`, insertion dans `mouvements_stock`.
  * Flux de données : base → DataFrame/JSON → front dashboards + ajustements per product.

## 7. Dashboard & prix
- `backend/api/dashboard.py` : renvoie `DashboardResponse` avec KPI, tops, statut.
- `backend/services/dashboard.py` :
  * `fetch_kpis`: totaux produits, valeur stock, quantités, alertes.
  * `fetch_top_stock_value`, `fetch_top_sales`, `fetch_status_distribution`, `fetch_supplier_breakdown`, `fetch_weekly_variation`, `fetch_margin_alerts`.
- `backend/api/prices.py` : relai sur `core.price_history_service.fetch_price_history`.
  * Fonctions et empreinte :
    - `fetch_dashboard_metrics` assemble plusieurs morceaux (kpis, tops, etc.), chaque fonction lisant la base via `query_df`.
    - `fetch_price_history` (dans `core/price_history_service`) est appelée pour alimenter les historiques prix.
  * Flux de données : agrégations SQL → JSON → graphique React/Streamlit.

## 8. Factures & extractions
- `backend/api/invoices.py` : 
  * `/extract` (texte) et `/extract/file` (PDF si python-multipart).
  * `/import` applique les lignes à `inventory_service.register_invoice_reception`.
  * `/catalog/import` crée/maj catalogue via `products_loader.load_products_from_df`.
- `backend/services/invoices.py` :
  * `extract_invoice_lines`: appelle `invoice_extractor.extract_products_from_metro_invoice`.
  * `enrich_lines_with_catalog`: match codes, ajoute infos produit + margin normalization (`invoice_utils.prepare_invoice_dataframe`).
  * `_prepare_lines_for_import`: ajoute `quantite_recue` si manquante, re-match si besoin.
  * Fonctions et empreinte :
    - `enrich_lines_with_catalog`, `apply_invoice_import`, `import_catalog_from_invoice`, `_prepare_lines_for_import`.
    - Utilise `core.inventory_service`, `core.products_loader`, `core.price_history_service`.
  * Flux de données : PDF/texte → extraction → enrichissement → matching vers `produits` → création mouvements → reporting.

## 9. Reporting
- `backend/api/reports.py` : `GET /overview` (KPIs + break-downs) et `GET /export/{report_type}` (CSV stock/alertes/rotation/stock négatif).
- `backend/services/reports.py` :
  * Fonctions `fetch_*` pour KPI, catégories, top valeur, rotation, fournisseurs.
  * `EXPORT_DEFINITIONS` décrit chaque export (SQL + nom fichier).
  * Fonctions et empreinte :
    - `build_overview`, `export_dataset`, `fetch_report_kpis`, etc., lisent `produits`, `movements_stock`.
    - `export_dataset` génère le CSV en mémoire puis le retourne via `StreamingResponse`.
  * Flux de données : données SQL → DataFrame → dictionnaires/CSV vers Swagger/front.

## 10. Capital & portefeuille
- `backend/api/capital.py` : `/capital/overview` combine `capital_snapshot` et `latest_price_history` pour décrire stocks + trésorerie par tenant et consolidé.
- `backend/services/capital.py` : calcule ces métriques en lisant les prix récents et les relevés bancaires, expose `persist_daily_snapshot()` pour alimenter `capital_snapshot`.
- `scripts/generate_capital_snapshot.py` permet de planifier la génération quotidienne de ces snapshots.
- Les rapports (`backend/services/reports.py`) intègrent le dernier snapshot via `fetch_latest_capital_snapshot()`, et la SPA consumme la page `Portefeuille` (cf. frontend docs).

## 10. Maintenance & backups
- `backend/api/maintenance.py` : liste + téléchargement des backups sur disque (path `/backups` ou `backups/`).
- `backend/services/maintenance.py` : `BACKUP_DIR` configurable, filtre `.gz/.sql/.zip`, retourne taille/date.
  * Fonctions et empreinte :
    - `list_backups` inspecte FS, retourne metadonnées (nom, taille, timestamp) et fournit le path complet.
  * Flux de données : lecture d’arborescence → JSON.

## 11. Admin
- `backend/api/admin.py` : overview, utilisateurs, rôles, mots de passe, backups CRUD, rapport d’intégrité, réglages sauvegarde.
- `backend/services/admin.py` :
  * Dépend du `core.backup_manager` pour création/restauration, suivi outils, statistiques.
  * Liste tables critiques (`produits`, `produits_barcodes`, `mouvements_stock`), diagnostics stock, mouvements récents.
  * `list_admin_users`, `update_role`, `reset_password` reprennent `core.user_service`.

## 12. Module Restaurant
- `backend/api/restaurant.py` : 
  * Catégories, cost centers, charges/dépenses, résumé mensuel.
  * Gestion ingrédients / plats (prix, marges, historique, attachement).
  * Relevés bancaires (CRUD, import PDF, lien dépenses).
  * Dashboard restaurant & historique prix (menus + ingrédients).
- `backend/services/restaurant.py` :
  * Extraction PDF complexe (LCL + SumUp) grâce à `PdfReader`, heuristiques `CATEGORY_RULES`, `_align_descriptions`, etc.
  * Tables métier : `restaurant_depense_categories`, `restaurant_cost_centers`, `restaurant_ingredients`, `restaurant_plats`, `restaurant_bank_statements`.
  * Fonctions : `list_depense_categories`, `create_depense_category`, `list_cost_centers`, `create_cost_center`, `list_ingredients`, `create_ingredient`, `update_ingredient_price`, `list_plats`, `create_plat`, `attach_ingredient_to_plat`, `update_plat_price`, `list_bank_statements`, `create_bank_statement`, `update_bank_statement`, `create_expense_from_bank_statement`, `import_bank_statements_from_pdf`, `build_dashboard_overview`, `list_recent_price_changes`.

## Fluxs récurrents / boucles métier clés
- **Facture → Catalogue** : extraction texte/PDF → enrichissement → match catalogue → création/mise à jour produit + price history → mouvement d’inventaire.
- **Audit → Action → Résolution** : diagnostic stock → création action (responsable/note/due date) → suivi du statut + log dans `audit_resolution_log`.
- **Restaurant expenses → Bank statements** : import PDF (heuristiques), détection doublons → lien vers dépense (`create_expense_from_bank_statement`).
- **Supply plan** : catalogue enrichi + ventes → couverture → quantité à commander → priorisation → ventilation fournisseurs.
- **Informe consolidé** : dashboards/reports utilisent les mêmes tables SQL (`produits`, `mouvements_stock`, `audit_actions`) pour produire KPI/métriques/exports, garantissant cohérence.

## Gaps immédiats
1. Authentification/autorisation globale (notamment `admin`, `maintenance`, `restaurant` exposés).
2. Documentation de la chaîne Auth/JWT/tenants (création du token, claims utilisés, verrouillage par entreprise).
3. Tests/contrôles pour les imports invoices/relevés (filtres, marges, montant).

## Prochaine direction de refonte
1. Ajouter un module “capital consolidé” qui additionne les deux tenants et expose l’évolution du capital et consommation (par ex. `/capital/overview`).
2. Structurer une API “finance” centrée sur les entrées/sorties (factures + relevés) : extraction → catégorisation → dashboard.
3. Prioriser la sécurisation des routes sensibles et la documentation (tu peux t’inspirer de cette carte mentale).  
  * Fonctions et empreinte :
    - `fetch_admin_overview`, `fetch_backup_overview`, `list_admin_users`, `update_role`, `reset_password`, `create_backup_now`, `restore_backup_file`, `delete_backup_file`.
    - Lit/écrit tables `tenants`, `audit_actions`, `audit_resolution_log`, `produits`, `mouvements_stock`, en plus des objets `core.backup_manager`.
  * Flux de données : stats (SQL/backups) → agrégation Python → API JSON.
  * Fonctions et empreinte :
    - `parse_bank_statement_pdf`, `import_bank_statements_from_pdf`, `list_bank_statements`, `create_expense_from_bank_statement`.
    - `list_plats`, `create_plat`, `attach_ingredient_to_plat`, `update_plat_price`, `build_dashboard_overview`, `list_recent_price_changes`.
    - Interagit avec tables `restaurant_*` (dépenses, ingrédients, plats, relevés).
  * Flux de données : relevé PDF → parsing heuristique → insertion/mise à jour dépenses/ingrédients → dashboards menus/client.
