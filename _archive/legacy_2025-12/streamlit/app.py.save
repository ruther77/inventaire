import os
import io
import pandas as pd
import streamlit as st
from sqlalchemy import create_engine, text

st.set_page_config(page_title="Inventaire √âpicerie", layout="wide")
DATABASE_URL = os.getenv("DATABASE_URL", "postgresql+psycopg2://postgres:postgres@localhost:5432/epicerie")

@st.cache_resource
def get_engine():
    return create_engine(DATABASE_URL, pool_pre_ping=True)

def exec_sql(sql, params=None):
    eng = get_engine()
    with eng.begin() as conn:
        if params is None:
            conn.execute(text(sql))
        else:
            conn.execute(text(sql), params)

def query_df(sql, params=None):
    eng = get_engine()
    with eng.begin() as conn:
        df = pd.read_sql(text(sql), conn, params=params)
    return df

# --- UI ---
st.title("üì¶ Inventaire ‚Äî D√©mo robuste")

catalog_tab, import_tab, admin_tab = st.tabs(["Catalogue", "Import", "Admin"])

with catalog_tab:
    st.subheader("Produits (vue rapide)")
    q = st.text_input("Recherche (nom ou code-barres)", "")
    sort = st.selectbox("Trier par", ["nom", "prix_vente", "tva", "id"], index=0)
    page_size = st.selectbox("Taille page", [25, 50, 100, 200], index=1)
    page = st.number_input("Page", min_value=1, value=1, step=1)

    offset = (page - 1) * page_size

    base_where = "WHERE 1=1"
    params = {}
    if q:
        base_where += " AND (LOWER(p.nom) LIKE LOWER(:q) OR b.code ILIKE :q)"
        params["q"] = f"%{q}%"

    total = query_df(f"""
        SELECT COUNT(*) AS n
        FROM public.produits p
        LEFT JOIN public.produits_barcodes b ON b.produit_id = p.id
        {base_where}
    """, params).iloc[0]["n"]

    st.caption(f"Total : {int(total)} produit(s)")
    df = query_df(f"""
        SELECT p.id, p.nom, p.prix_vente, p.tva, 
               COALESCE(string_agg(DISTINCT b.code, ', '), '') AS codes
        FROM public.produits p
        LEFT JOIN public.produits_barcodes b ON b.produit_id = p.id
        {base_where}
        GROUP BY p.id
        ORDER BY {sort} ASC
        LIMIT :limit OFFSET :offset
    """, {**params, "limit": int(page_size), "offset": int(offset)})

    st.dataframe(
        df,
        use_container_width=True,
        column_config={
            "prix_vente": st.column_config.NumberColumn("Prix (‚Ç¨)", format="%.2f"),
            "tva": st.column_config.NumberColumn("TVA (%)", format="%.2f"),
            "codes": st.column_config.TextColumn("Codes-barres"),
        }
    )


if not df.empty:
    csv = df.to_csv(index=False).encode("utf-8")
    st.download_button("‚¨áÔ∏è Exporter la s√©lection (CSV)", data=csv, file_name="produits_export.csv", mime="text/csv")


with import_tab:
    st.subheader("Importer des produits (CSV ou Excel)")
    up = st.file_uploader("D√©posez un fichier .csv ou .xlsx ...", type=["csv","xlsx"], accept_multiple_files=False)

    def to_float(x, default=0.0, minv=None, maxv=None):
    import math
    if x is None: return default
    try:
        if isinstance(x, float) and math.isnan(x): return default
    except: pass
    s = str(x).replace("‚Ç¨","").replace("\xa0","").replace(" ","").replace(",", ".").strip()
    try:
        v = float(s)
        if minv is not None: v = max(v, minv)
        if maxv is not None: v = min(v, maxv)
        return round(v, 4)
    except:
        return default


    if up:
        import re
        try:
            if up.name.lower().endswith(".csv"):
                try:
                    df = pd.read_csv(up)
                except Exception:
                    df = pd.read_csv(up, sep=";")
            else:
                df = pd.read_excel(up)
        except Exception as e:
            st.error(f"Erreur de lecture du fichier: {e}")
            df = None

        if df is not None:
            cols_map = {
                "Nom":"nom","nom":"nom",
                "Prix de vente":"prix_vente","prix_vente":"prix_vente","prix":"prix_vente",
                "TVA":"tva","tva":"tva",
                "Code-barres":"codes","codes":"codes","code_barres":"codes","barcode":"codes","ean":"codes",
                "qte_init":"qte_init","Quantit√© disponible":"qte_init","stock_initial":"qte_init"
            }
            df2 = df.rename(columns={c: cols_map.get(c,c) for c in df.columns})

            if "nom" not in df2.columns:
                st.error("Colonne obligatoire manquante : 'Nom'.")
                st.stop()

            if "tva" not in df2.columns: df2["tva"] = 0.0
            if "prix_vente" not in df2.columns: df2["prix_vente"] = 0.0
            if "qte_init" not in df2.columns: df2["qte_init"] = 0.0

            # normaliser les valeurs num√©riques
            df2["tva"] = df2["tva"].map(to_float)
            df2["prix_vente"] = df2["prix_vente"].map(to_float)
            df2["qte_init"] = df2["qte_init"].map(to_float)

            eng = get_engine()
            created=updated=stocked=codes_added=0
            errors = []

            # On utilise une connexion longue + mini-transactions par ligne
            with eng.connect() as conn:
                for i, row in df2.iterrows():
                    nom = str(row["nom"]).strip() if pd.notna(row["nom"]) else ""
                    if not nom:
                        continue
                    tva = row["tva"]
                    pv  = row["prix_vente"]
                    qte = row["qte_init"]
                    codes_raw = str(row.get("codes","")).strip()

                    trans = conn.begin()  # mini-transaction
                    try:
                        r = conn.execute(text("SELECT id FROM produits WHERE LOWER(nom)=LOWER(:n)"), {"n": nom}).fetchone()
                        if r:
                            pid = r[0]
                            conn.execute(
                                text("UPDATE produits SET prix_vente=:pv, tva=:tva WHERE id=:id"),
                                {"pv": pv, "tva": tva, "id": pid}
                            )
                            updated += 1
                        else:
                            r = conn.execute(
                                text("""
                                    INSERT INTO produits(nom, prix_vente, tva, actif)
                                    VALUES (:n, :pv, :tva, TRUE)
                                    RETURNING id
                                """),
                                {"n": nom, "pv": pv, "tva": tva}
                            )
                            pid = r.scalar()
                            created += 1

                        if qte and qte != 0:
                            conn.execute(
                                text("""
                                    INSERT INTO mouvements_stock(produit_id, type, quantite, source)
                                    VALUES (:pid, 'ENTREE', :qte, 'IMPORT_INITIAL')
                                """),
                                {"pid": pid, "qte": qte}
                            )
                            stocked += 1

                        if codes_raw and codes_raw.lower() != "nan":
                            parts = [c.strip() for c in re.split(r"[;,\s]+", codes_raw) if c.strip()]
                            for code in parts:
                                # √©vite l'√©chec global si doublon
                                conn.execute(
                                    text("""
                                        INSERT INTO produits_barcodes(produit_id, code)
                                        VALUES (:pid, :code)
                                        ON CONFLICT DO NOTHING
                                    """),
                                    {"pid": pid, "code": code}
                                )
                                codes_added += 1

                        trans.commit()
                    except Exception as e:
                        trans.rollback()  # on annule la ligne fautive, et on continue
                        errors.append((i, nom, str(e)))

            msg = f"Import OK ‚Äî cr√©√©s: {created}, mis √† jour: {updated}, stocks initiaux: {stocked}, codes-barres ajout√©s: {codes_added}."
            if errors:
                st.warning(msg + f" ‚ö†Ô∏è {len(errors)} lignes ignor√©es (voir d√©tails ci-dessous).")
                with st.expander("D√©tails des erreurs"):
                    for i, nom, err in errors[:200]:
                        st.write(f"Ligne {i} ‚Äî ¬´ {nom} ¬ª : {err}")
            else:
                st.success(msg)

            st.dataframe(df2.head(50))


with admin_tab:
    st.subheader("Maintenance")
    st.write("‚Ä¢ V√©rifier la connexion BDD")
    if st.button("Tester la connexion"):
        try:
            df = query_df("SELECT NOW() as now")
            st.success(f"Connexion OK ‚Äî serveur r√©pond: {df.loc[0,'now']}")
        except Exception as e:
            st.error("Connexion √©chou√©e :")
            st.exception(e)

    st.divider()
    st.write("‚Ä¢ Aper√ßu des tables")
    for t in ["produits","produits_barcodes","mouvements_stock"]:
        try:
            df = query_df(f"SELECT * FROM {t} LIMIT 20")
            st.write(f"Table **{t}**")
            st.dataframe(df, use_container_width=True)
        except Exception as e:
            st.info(f"Table {t} indisponible : {e}")
